# Telegram Gift Auction — Архитектура и логика

## Как работает аукцион

- Каждый аукцион состоит из нескольких раундов.
- В каждом раунде разыгрывается часть призов (giftsPerRound).
- В каждом раунде участники делают ставки. Ставка должна быть не ниже минимальной и кратна инкременту.
- В конце раунда выигрывают N участников с самыми высокими ставками (N = giftsPerRound).
- Победители получают приз, их средства списываются. Остальным возвращаются заблокированные средства.
- После завершения раунда начинается следующий, пока не разыграны все призы.
- Есть anti-sniping: если ставка сделана в последние X секунд, раунд продлевается.

## Логика ставок и баланса

- При ставке средства блокируются на балансе пользователя.
- Если пользователь перебивает свою ставку — блокируется только разница.
- Если ставка перебита другим — средства разблокируются.
- Победителям средства списываются окончательно.
- Проигравшим возвращаются.
- Все операции логируются в коллекции Transaction.

## Edge-cases и допущения

- Одновременные ставки: используется Redis-лок для предотвращения гонок.
- Если пользователь делает несколько ставок подряд — учитывается только максимальная.
- Если два пользователя делают одинаковую ставку — выигрывает тот, кто сделал её раньше.
- Если раунд отменён или аукцион отменён — все средства возвращаются.
- Если пользователь отключился — его ставка остаётся в силе.
- Если возникла ошибка при обработке — транзакция откатывается, деньги не теряются.

## Архитектурные решения

- Node.js + TypeScript + MongoDB + Redis.
- Все критичные операции проходят в транзакциях MongoDB.
- Для конкурентности — Redis-локи на аукцион/раунд.
- Баланс пользователя: available + locked.
- Все изменения баланса логируются (Transaction).
- API покрывает все сценарии: создание аукциона, ставки, возвраты, история, бонусы, переводы.
- Есть stress-test для проверки под нагрузкой.

## Что ещё можно улучшить

- Добавить автоматические тесты edge-cases.
- Реализовать полноценный UI для демонстрации.
- Ввести мониторинг и алерты.
- Описать все допущения и решения в README/spec.
